API Reference
This is the long list of functions you can use. Remember that you don't need to remember all of those and that you can already make music with a small set of functions!


s
Synonyms: sound

Select a sound / sample by name. When using mininotation, you can also optionally supply 'n' and 'gain' parameters separated by ':'.


sound : string | Pattern - The sound / pattern of sounds to pick
s("bd hh")
s("bd:0 bd:1 bd:0:0.3 bd:1:1.4")
samples
Loads a collection of samples to use with s


samples('github:tidalcycles/dirt-samples');
s("[bd ~]*2, [~ hh]*2, ~ sd")
samples({
 bd: '808bd/BD0000.WAV',
 sd: '808sd/SD0010.WAV'
 }, 'https://raw.githubusercontent.com/tidalcycles/Dirt-Samples/master/');
s("[bd ~]*2, [~ hh]*2, ~ sd")
samples('shabda:noise,chimp:2')
s("noise <chimp:0*2 chimp:1>")
samples('shabda/speech/fr-FR/f:chocolat')
s("chocolat*4")
saw
A sawtooth signal between 0 and 1.


note("<c3 [eb3,g3] g2 [g3,bb3]>*8")
.clip(saw.slow(2))
n(saw.range(0,8).segment(8))
.scale('C major')
saw2
A sawtooth signal between -1 and 1 (like saw, but bipolar).


scale
Turns numbers into notes in the scale (zero indexed). Also sets scale for other scale operations, like {@link Pattern#scaleTranspose}.

A scale consists of a root note (e.g. c4, c, f#, bb4) followed by semicolon (':') and then a scale type.

The root note defaults to octave 3, if no octave number is given.


scale : string - Name of scale
n("0 2 4 6 4 2").scale("C:major")
n("[0,7] 4 [2,7] 4")
.scale("C:<major minor>/2")
.s("piano")
n(rand.range(0,12).segment(8))
.scale("C:ritusen")
.s("piano")
scaleTranspose
Synonyms: scaleTrans, strans

Transposes notes inside the scale by the number of steps. Expected to be called on a Pattern which already has a {@link Pattern#scale}


offset : offset - number of steps inside the scale
"-8 [2,4,6]"
.scale('C4 bebop major')
.scaleTranspose("<0 -1 -2 -3 -4 -5 -6 -4>")
.note()
scope
Synonyms: tscope

Renders an oscilloscope for the time domain of the audio signal.


config : object - optional config with options:
align : boolean - if 1, the scope will be aligned to the first zero crossing. defaults to 1
color : string - line color as hex or color name. defaults to white.
thickness : number - line thickness. defaults to 3
scale : number - scales the y-axis. Defaults to 0.25
pos : number - y-position relative to screen height. 0 = top, 1 = bottom of screen
trigger : number - amplitude value that is used to align the scope. defaults to 0.
s("sawtooth")._scope()
scramble
Slices a pattern into the given number of parts, then plays those parts at random. Similar to shuffle, but parts might be played more than once, or not at all, per cycle.


note("c d e f").sound("piano").scramble(4)
seq("c d e f".scramble(4), "g").note().sound("piano")
scrub
Allows you to scrub an audio file like a tape loop by passing values that represents the position in the audio file in the optional array syntax ex: "0.5:2", the second value controls the speed of playback


samples('github:switchangel/pad')
s("swpad:0").scrub("{0.1!2 .25@3 0.7!2 <0.8:1.5>}%8")
samples('github:yaxu/clean-breaks/main');
s("amen/4").fit().scrub("{0@3 0@2 4@3}%8".div(16))
segment
Synonyms: seg

Samples the pattern at a rate of n events per cycle. Useful for turning a continuous pattern into a discrete one.


segments : number - number of segments per cycle
note(saw.range(40,52).segment(24))
seq
Synonyms: sequence, fastcat

Like cat, but the items are crammed into one cycle.


seq("e5", "b4", ["d5", "c5"]).note()
// "e5 b4 [d5 c5]".note()
// As a chained function:
s("hh*4").seq(
  note("c4(5,8)")
)
seqPLoop
Similarly to arrange, allows you to arrange multiple patterns together over multiple cycles. Unlike arrange, you specify a start and stop time for each pattern rather than duration, which means that patterns can overlap.


seqPLoop([0, 2, "bd(3,8)"],
         [1, 3, "cp(3,8)"]
        )
  .sound()
sequence
See fastcat


sequenceP
Takes a list of patterns, and returns a pattern of lists.


setContext
Returns a new pattern with the context field set to every hap set to the given value.


context : *
setcpm
Changes the global tempo to the given cycles per minute


cpm : number - cycles per minute
setcpm(140/4) // =140 bpm in 4/4
$: s("bd*4,[- sd]*2").bank('tr707')
shape
(Deprecated) Wave shaping distortion. WARNING: can suddenly get unpredictably loud. Please use distort instead, which has a more predictable response curve second option in optional array syntax (ex: ".9:.5") applies a postgain to the output


distortion : number | Pattern - between 0 and 1
s("bd sd [~ bd] sd,hh*8").shape("<0 .2 .4 .6 .8>")
shiftInputBuffers
Shift left content of input buffers to receive new web audio block


shiftOutputBuffers
Shift left content of output buffers to receive new web audio block


shiftPeaks
Shift peaks and regions of influence by pitchFactor into new specturm


showFirstCycle
More human-readable version of the firstCycleValues accessor.


shrink
Experimental

Progressively shrinks the pattern by 'n' steps until there's nothing left, or if a second value is given (using mininotation list syntax with :), that number of times. A positive number will progressively drop steps from the start of a pattern, and a negative number from the end.


"tha dhi thom nam".shrink("1").sound()
.bank("mridangam")
"tha dhi thom nam".shrink("-1").sound()
.bank("mridangam")
"tha dhi thom nam".shrink("1 -1").sound().bank("mridangam").pace(4)
note("0 1 2 3 4 5 6 7".scale("C:ritusen")).sound("folkharp")
   .shrink("1 -1").pace(8)
shuffle
Slices a pattern into the given number of parts, then plays those parts in random order. Each part will be played exactly once per cycle.


note("c d e f").sound("piano").shuffle(4)
seq("c d e f".shuffle(4), "g").note().sound("piano")
silence
Does absolutely nothing..


silence // "~"
sine
A sine signal between 0 and 1.


n(sine.segment(16).range(0,15))
.scale("C:minor")
sine2
A sine signal between -1 and 1 (like sine, but bipolar).


slice
Chops samples into the given number of slices, triggering those slices with a given pattern of slice numbers. Instead of a number, it also accepts a list of numbers from 0 to 1 to slice at specific points.


samples('github:tidalcycles/dirt-samples')
s("breaks165").slice(8, "0 1 <2 2*2> 3 [4 0] 5 6 7".every(3, rev)).slow(0.75)
samples('github:tidalcycles/dirt-samples')
s("breaks125").fit().slice([0,.25,.5,.75], "0 1 1 <2 3>")
slider
Displays a slider widget to allow the user manipulate a value


value : number - Initial value
min : number - Minimum value - optional, defaults to 0
max : number - Maximum value - optional, defaults to 1
step : number - Step size - optional
slow
Synonyms: sparsity

Slow down a pattern over the given number of cycles. Like the "/" operator in mini notation.


factor : number | Pattern - slow down factor
s("bd hh sd hh").slow(2) // s("[bd hh sd hh]/2")
slowcat
Concatenation: combines a list of patterns, switching between them successively, one per cycle:

synonyms: cat


slowcat("e5", "b4", ["d5", "c5"])
slowcatPrime
Concatenation: combines a list of patterns, switching between them successively, one per cycle. Unlike slowcat, this version will skip cycles.


items : any - The items to concatenate
someCycles
Shorthand for .someCyclesBy(0.5, fn)


s("bd,hh*8").someCycles(x=>x.speed("0.5"))
someCyclesBy
Randomly applies the given function by the given probability on a cycle by cycle basis. Similar to sometimesBy


probability : number | Pattern - a number between 0 and 1
function : function - the transformation to apply
s("bd,hh*8").someCyclesBy(.3, x=>x.speed("0.5"))
sometimes
Applies the given function with a 50% chance


function : function - the transformation to apply
s("hh*8").sometimes(x=>x.speed("0.5"))
sometimesBy
Randomly applies the given function by the given probability. Similar to someCyclesBy


probability : number | Pattern - a number between 0 and 1
function : function - the transformation to apply
s("hh*8").sometimesBy(.4, x=>x.speed("0.5"))
sortHapsByPart
Returns a new pattern, which returns haps sorted in temporal order. Mainly of use when comparing two patterns for equality, in tests.


source
Synonyms: src

Define a custom webaudio node to use as a sound source.


getSource : function
spectrum
Renders a spectrum analyzer for the incoming audio signal.


config : object - optional config with options:
thickness : integer - line thickness in px (default 3)
speed : integer - scroll speed (default 1)
min : integer - min db (default -80)
max : integer - max db (default 0)
n("<0 4 <2 3> 1>*3")
.off(1/8, add(n(5)))
.off(1/5, add(n(7)))
.scale("d3:minor:pentatonic")
.s('sine')
.dec(.3).room(.5)
._spectrum()
speed
Changes the speed of sample playback, i.e. a cheap way of changing pitch.


speed : number | Pattern - inf to inf, negative numbers play the sample backwards.
s("bd*6").speed("1 2 4 1 -2 -4")
speed("1 1.5*2 [2 1.1]").s("piano").clip(1)
spiral
Displays a spiral visual.


options : Object - Object containing all the optional following parameters as key value pairs:
stretch : number - controls the rotations per cycle ratio, where 1 = 1 cycle / 360 degrees
size : number - the diameter of the spiral
thickness : number - line thickness
cap : string - style of line ends: butt (default), round, square
inset : string - number of rotations before spiral starts (default 3)
playheadColor : string - color of playhead, defaults to white
playheadLength : number - length of playhead in rotations, defaults to 0.02
playheadThickness : number - thickness of playheadrotations, defaults to thickness
padding : number - space around spiral
steady : number - steadyness of spiral vs playhead. 1 = spiral doesn't move, playhead does.
activeColor : number - color of active segment. defaults to foreground of theme
inactiveColor : number - color of inactive segments. defaults to gutterForeground of theme
colorizeInactive : boolean - wether or not to colorize inactive segments, defaults to 0
fade : boolean - wether or not past and future should fade out. defaults to 1
logSpiral : boolean - wether or not the spiral should be logarithmic. defaults to 0
note("c2 a2 eb2")
.euclid(5,8)
.s('sawtooth')
.lpenv(4).lpf(300)
._spiral({ steady: .96 })
splice
Works the same as slice, but changes the playback speed of each slice to match the duration of its step.


samples('github:tidalcycles/dirt-samples')
s("breaks165")
.splice(8,  "0 1 [2 3 0]@2 3 0@2 7")
splitQueries
Returns a new pattern, with queries split at cycle boundaries. This makes some calculations easier to express, as all haps are then constrained to happen within a cycle.


spread
Set the stereo pan spread for supported oscillators


spread : number | Pattern - between 0 and 1
note("d f a a# a d3").fast(2).s("supersaw").spread("<0 .3 1>")
square
A square signal between 0 and 1.


n(square.segment(4).range(0,7)).scale("C:minor")
square2
A square signal between -1 and 1 (like square, but bipolar).


squeeze
Pick from the list of values (or patterns of values) via the index using the given pattern of integers. The selected pattern will be compressed to fit the duration of the selecting event


pat : Pattern
xs : *
note(squeeze("<0@2 [1!2] 2>", ["g a", "f g f g" , "g a c d"]))
squiz
Made by Calum Gunn. Reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter. The SuperCollider manual defines Squiz as:

"A simplistic pitch-raising algorithm. It's not meant to sound natural; its sound is reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter, depending on the input. The algorithm works by cutting the signal into fragments (delimited by upwards-going zero-crossings) and squeezing those fragments in the time domain (i.e. simply playing them back faster than they came in), leaving silences inbetween. All the parameters apart from memlen can be modulated."


squiz : number | Pattern - Try passing multiples of 2 to it - 2, 4, 8 etc.
squiz("2 4/2 6 [8 16]").s("bd").osc()
stack
Synonyms: polyrhythm, pr

The given items are played at the same time at the same length.


stack("g3", "b3", ["e4", "d4"]).note()
// "g3,b3,[e4 d4]".note()
// As a chained function:
s("hh*4").stack(
  note("c4(5,8)")
)
stepalt
Experimental

Concatenates patterns stepwise, according to an inferred 'steps per cycle'. Similar to stepcat, but if an argument is a list, the whole pattern will alternate between the elements in the list.


stepalt(["bd cp", "mt"], "bd").sound()
// The same as "bd cp bd mt bd".sound()
stepcat
Synonyms: timeCat, timecat

'Concatenates' patterns like fastcat, but proportional to a number of steps per cycle. The steps can either be inferred from the pattern, or provided as a [length, pattern] pair. Has the alias timecat.


stepcat([3,"e3"],[1, "g3"]).note()
// the same as "e3@3 g3".note()
stepcat("bd sd cp","hh hh").sound()
// the same as "bd sd cp hh hh".sound()
stretch
Changes the speed of sample playback, i.e. a cheap way of changing pitch.


factor : number | Pattern - inf to inf, negative numbers play the sample backwards.
s("gm_flute").stretch("1 2 .5")
striate
Cuts each sample into the given number of parts, triggering progressive portions of each sample at each loop.


s("numbers:0 numbers:1 numbers:2").striate(6).slow(3)
stripContext
Returns a new pattern with the context field of every hap set to an empty object.


struct
Applies the given structure to the pattern:


note("c,eb,g")
  .struct("x ~ x ~ ~ x ~ x ~ ~ ~ x ~ x ~ ~")
  .slow(2)
stut
Deprecated. Like echo, but the last 2 parameters are flipped.


times : number - how many times to repeat
feedback : number - velocity multiplicator for each iteration
time : number - cycle offset between iterations
s("bd sd").stut(3, .8, 1/6)
sub
Like add, but the given numbers are subtracted.


n("0 2 4".sub("<0 1 2 3>")).scale("C4:minor")
// See add for more information.
superimpose
Superimposes the result of the given function(s) on top of the original pattern:


"<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
  .superimpose(x=>x.add(2))
  .scale('C minor').note()
sustain
Synonyms: sus

Amplitude envelope sustain level: The level which is reached after attack / decay, being sustained until the offset.


gain : number | Pattern - sustain level between 0 and 1
note("c3 e3 f3 g3").decay(.2).sustain("<0 .1 .4 .6 1>")
swing
Shorthand for swingBy with 1/3:


subdivision : number
s("hh*8").swing(4)
// s("hh*8").swingBy(1/3, 4)
swingBy
The function swingBy x n breaks each cycle into n slices, and then delays events in the second half of each slice by the amount x, which is relative to the size of the (half) slice. So if x is 0 it does nothing, 0.5 delays for half the note duration, and 1 will wrap around to doing nothing again. The end result is a shuffle or swing-like rhythm


subdivision : number
offset : number
s("hh*8").swingBy(1/3, 4)
sysex
MIDI sysex: Sends a MIDI sysex message.


id : number | Pattern - Sysex ID
data : number | Pattern - Sysex data
note("c4").sysex(["0x77", "0x01:0x02:0x03:0x04"]).midichan(1).midi()
sysexdata
MIDI sysex data: Sends a MIDI sysex message.


data : number | Pattern - Sysex data
note("c4").sysexid("0x77").sysexdata("0x01:0x02:0x03:0x04").midichan(1).midi()
sysexid
MIDI sysex ID: Sends a MIDI sysex identifier message.


id : number | Pattern - Sysex ID
note("c4").sysexid("0x77").sysexdata("0x01:0x02:0x03:0x04").midichan(1).midi()
tag
Tags each Hap with an identifier. Good for filtering. The function populates Hap.context.tags (Array).


tag : string - anything unique
take
Experimental

Takes the given number of steps from a pattern (dropping the rest). A positive number will take steps from the start of a pattern, and a negative number from the end.


"bd cp ht mt".take("2").sound()
// The same as "bd cp".sound()
"bd cp ht mt".take("1 2 3").sound()
// The same as "bd bd cp bd cp ht".sound()
"bd cp ht mt".take("-1 -2 -3").sound()
// The same as "mt ht mt cp ht mt".sound()
time
A signal representing the cycle time.


timecat
Aliases for stepcat


toBipolar
Assumes a numerical pattern, containing unipolar values in the range 0 ..

Returns a new pattern with values scaled to the bipolar range -1 .. 1

tour
Experimental

Inserts a pattern into a list of patterns. On the first repetition it will be inserted at the end of the list, then moved backwards through the list on successive repetitions. The patterns are added together stepwise, with all repetitions taking place over a single cycle. Using pace to set the number of steps per cycle is therefore usually recommended.


"[c g]".tour("e f", "e f g", "g f e c").note()
   .sound("folkharp")
   .pace(8)
transpose
Synonyms: trans

Change the pitch of each value by the given amount. Expects numbers or note strings as values. The amount can be given as a number of semitones or as a string in interval short notation. If you don't care about enharmonic correctness, just use numbers. Otherwise, pass the interval of the form: ST where S is the degree number and T the type of interval with

M = major
m = minor
P = perfect
A = augmented
d = diminished
Examples intervals:

1P = unison
3M = major third
3m = minor third
4P = perfect fourth
4A = augmented fourth
5P = perfect fifth
5d = diminished fifth

amount : string | number - Either number of semitones or interval string.
"c2 c3".fast(2).transpose("<0 -2 5 3>".slow(2)).note()
"c2 c3".fast(2).transpose("<1P -2M 4P 3m>".slow(2)).note()
tremolo
Synonyms: trem

modulate the amplitude of a sound with a continuous waveform


speed : number | Pattern - modulation speed in HZ
note("d d d# d".fast(4)).s("supersaw").tremolo("<3 2 100> ").tremoloskew("<.5>")
tremolodepth
Synonyms: tremdepth

depth of amplitude modulation


depth : number | Pattern
note("a1 a1 a#1 a1".fast(4)).s("pulse").tremsync(4).tremolodepth("<1 2 .7>")
tremolophase
Synonyms: tremphase

alter the phase of the modulation waveform


offset : number | Pattern - the offset in cycles of the modulation
note("{f a c e}%16").s("sawtooth").tremsync(4).tremolophase("<0 .25 .66>")
tremoloshape
shape of amplitude modulation


shape : number | Pattern - tri | square | sine | saw | ramp
note("{f g c d}%16").tremsync(4).tremoloshape("<sine tri square>").s("sawtooth")
tremoloskew
Synonyms: tremskew

alter the shape of the modulation waveform


amount : number | Pattern - between 0 & 1, the shape of the waveform
note("{f a c e}%16").s("sawtooth").tremsync(4).tremoloskew("<.5 0 1>")
tremolosync
Synonyms: tremsync

modulate the amplitude of a sound with a continuous waveform


cycles : number | Pattern - modulation speed in cycles
note("d d d# d".fast(4)).s("supersaw").tremolosync("4").tremoloskew("<1 .5 0>")
tri
A triangle signal between 0 and 1.


n(tri.segment(8).range(0,7)).scale("C:minor")
tri2
A triangle signal between -1 and 1 (like tri, but bipolar).


undegrade
Inverse of degrade: Randomly removes 50% of events from the pattern. Shorthand for .undegradeBy(0.5) Events that would be removed by degrade are let through by undegrade and vice versa (see second example).


s("hh*8").undegrade()
s("hh*10").layer(
  x => x.degrade().pan(0),
  x => x.undegrade().pan(1)
)
undegradeBy
Inverse of degradeBy: Randomly removes events from the pattern by a given amount. 0 = 100% chance of removal 1 = 0% chance of removal Events that would be removed by degradeBy are let through by undegradeBy and vice versa (see second example).


amount : number - a number between 0 and 1
s("hh*8").undegradeBy(0.2)
s("hh*10").layer(
  x => x.degradeBy(0.2).pan(0),
  x => x.undegradeBy(0.8).pan(1)
)
unison
Set number of stacked voices for supported oscillators


numvoices : number | Pattern
note("d f a a# a d3").fast(2).s("supersaw").unison("<1 2 7>")
unit
Used in conjunction with speed, accepts values of "r" (rate, default behavior), "c" (cycles), or "s" (seconds). Using unit "c" means speed will be interpreted in units of cycles, e.g. speed "1" means samples will be stretched to fill a cycle. Using unit "s" means the playback speed will be adjusted so that the duration is the number of seconds specified by speed.


unit : number | string | Pattern - see description above
speed("1 2 .5 3").s("bd").unit("c").osc()
velocity
Sets the velocity from 0 to 1. Is multiplied together with gain.


s("hh*8")
.gain(".4!2 1 .4!2 1 .4 1")
.velocity(".4 1")
vib
Synonyms: vibrato, v

Applies a vibrato to the frequency of the oscillator.


frequency : number | Pattern - of the vibrato in hertz
note("a e")
.vib("<.5 1 2 4 8 16>")
._scope()
// change the modulation depth with ":"
note("a e")
.vib("<.5 1 2 4 8 16>:12")
._scope()
vibmod
Synonyms: vmod

Sets the vibrato depth in semitones. Only has an effect if vibrato | vib | v is is also set


depth : number | Pattern - of vibrato (in semitones)
note("a e").vib(4)
.vibmod("<.25 .5 1 2 12>")
._scope()
// change the vibrato frequency with ":"
note("a e")
.vibmod("<.25 .5 1 2 12>:8")
._scope()
voicing
Turns chord symbols into voicings. You can use the following control params:

chord: Note, followed by chord symbol, e.g. C Am G7 Bb^7
dict: voicing dictionary to use, falls back to default dictionary
anchor: the note that is used to align the chord
mode: how the voicing is aligned to the anchor
below: top note <= anchor
duck: top note <= anchor, anchor excluded
above: bottom note >= anchor
offset: whole number that shifts the voicing up or down to the next voicing
n: if set, the voicing is played like a scale. Overshooting numbers will be octaved
All of the above controls are optional, except chord. If you pass a pattern of strings to voicing, they will be interpreted as chords.


n("0 1 2 3").chord("<C Am F G>").voicing()
voicings
DEPRECATED: still works, but it is recommended you use .voicing instead (without s). Turns chord symbols into voicings, using the smoothest voice leading possible. Uses chord-voicings package.


dictionary : string - which voicing dictionary to use.
stack("<C^7 A7 Dm7 G7>".voicings('lefthand'), "<C3 A2 D3 G2>").note()
vowel
Formant filter to make things sound like vowels.


vowel : string | Pattern - You can use a e i o u ae aa oe ue y uh un en an on, corresponding to [a] [e] [i] [o] [u] [æ] [ɑ] [ø] [y] [ɯ] [ʌ] [œ̃] [ɛ̃] [ɑ̃] [ɔ̃]. Aliases: aa = å = ɑ, oe = ø = ö, y = ı, ae = æ.
note("[c2 <eb2 <g2 g1>>]*2").s('sawtooth')
.vowel("<a e i <o u>>")
s("bd sd mt ht bd [~ cp] ht lt").vowel("[a|e|i|o|u]")
wchoose
Chooses randomly from the given list of elements by giving a probability to each element


pairs : any - arrays of value and weight
note("c2 g2!2 d2 f1").s(wchoose(["sine",10], ["triangle",1], ["bd:6",1]))
wchooseCycles
Synonyms: wrandcat

Picks one of the elements at random each cycle by giving a probability to each element


wchooseCycles(["bd",10], ["hh",1], ["sd",1]).s().fast(8)
wchooseCycles(["bd bd bd",5], ["hh hh hh",3], ["sd sd sd",1]).fast(4).s()
// The probability can itself be a pattern
wchooseCycles(["bd(3,8)","<5 0>"], ["hh hh hh",3]).fast(4).s()
when
Applies the given function whenever the given pattern is in a true state.


binary_pat : Pattern
func : function
"c3 eb3 g3".when("<0 1>/2", x=>x.sub("5")).note()
whenKey
Do something on a keypress, or array of keypresses Key name reference


s("bd(5,8)").whenKey("Control:j", x => x.segment(16).color("red")).whenKey("Control:i", x => x.fast(2).color("blue"))
withContext
Returns a new pattern with the given function applied to the context field of every hap.


func : function
withHap
As with withHaps, but applies the function to every hap, rather than every list of haps.


func : function
withHapSpan
Similar to withQuerySpan, but the function is applied to the timespans of all haps returned by pattern queries (both part timespans, and where present, whole timespans).


func : function
withHapTime
As with withHapSpan, but the function is applied to both the begin and end time of the hap timespans.


func : function - the function to apply
withHaps
Returns a new pattern with the given function applied to the list of haps returned by every query.


func : function
withLoc
Returns a new pattern with the given location information added to the context of every hap.


start : Number - start offset
end : Number - end offset
withQuerySpan
Returns a new pattern, where the given function is applied to the query timespan before passing it to the original pattern.


func : function - the function to apply
withQueryTime
As with withQuerySpan, but the function is applied to both the begin and end time of the query timespan.


func : function - the function to apply
withValue
Synonyms: fmap

Returns a new pattern, with the function applied to the value of each hap. It has the alias fmap.


func : function - to to apply to the value
"0 1 2".withValue(v => v + 10).log()
within
Use within to apply a function to only a part of a pattern.


start : number - start within cycle (0 - 1)
end : number - end within cycle (0 - 1). Must be > start
func : function - function to be applied to the sub-pattern
wordfall
Displays a vertical pianoroll with event labels. Supports all the same options as pianoroll.


writeOutputs
Write next web audio block from output buffers


xfade
Cross-fades between left and right from 0 to 1:

0 = (full left, no right)
.5 = (both equal)
1 = (no left, full right)

xfade(s("bd*2"), "<0 .25 .5 .75 1>", s("hh*8"))
zip
Experimental

'zips' together the steps of the provided patterns. This can create a long repetition, taking place over a single, dense cycle. Using pace to set the number of steps per cycle is therefore usually recommended.


zip("e f", "e f g", "g [f e] a f4 c").note()
   .sound("folkharp")
   .pace(8)
zoom
Plays a portion of a pattern, specified by the beginning and end of a time span. The new resulting pattern is played over the time period of the original pattern:


s("bd*2 hh*3 [sd bd]*2 perc").zoom(0.25, 0.75)
// s("hh*3 [sd bd]*2") // equivalent

